# 동시성 제어와 자바 스레드 - 발표 스크립트

> 각 슬라이드별 발표 대본 및 설명 포인트

---

## 🎬 발표 시작 전

**준비사항:**
- 마이크 테스트
- 화면 공유 확인
- 데모 환경 준비
- 물 한 잔 준비
- 깊게 숨 쉬기 3회

**오프닝 멘트:**
```
안녕하세요, 여러분! 오늘은 제가 실제 프로젝트에서 마주쳤던
동시성 문제와 그 해결 과정에 대해 이야기해보려고 합니다.

혹시 여러분 중에 "1000명의 사용자가 동시에 버튼을 클릭하면 어떻게 될까?"
이런 생각을 해보신 적 있으신가요?

저는 실제로 이 문제를 마주쳤고, 오늘 그 경험을 공유하고자 합니다.
편하게 들어주시고, 궁금한 점 있으시면 언제든 질문해주세요!
```

---

## 1부: 기(起) - 문제의 발견

### 슬라이드 1: 타이틀

**스크립트:**
```
오늘 발표 주제는 "동시성 제어와 자바 스레드"입니다.
부제를 보시면 "실무에서 마주친 Race Condition 해결기"라고 적혀있는데요,
말 그대로 제가 실제로 겪고 해결한 이야기입니다.

(잠시 멈춤)

이론도 중요하지만, 실제로 부딪혀보고 해결하는 과정에서
더 많은 것을 배울 수 있다고 생각합니다.
```

**포인트:**
- 자신감 있는 목소리
- 청중과 아이컨택
- 미소 짓기

---

### 슬라이드 2: 문제 상황 소개

**스크립트:**
```
제가 개발 중이던 커뮤니티 서비스에는 댓글 좋아요 기능이 있었습니다.
별로 복잡해 보이지 않는 기능이죠?

그런데 부하 테스트를 하던 중, 이상한 현상을 발견했습니다.

(화면을 가리키며)
1000명의 사용자가 동시에 좋아요를 눌렀을 때,
예상으로는 1000개의 좋아요가 카운트되어야 하는데...

실제로는 300개, 500개, 매번 다른 숫자가 나왔습니다.

(잠시 멈춤)

"뭐가 문제지?"

이게 바로 동시성 문제, Race Condition이었습니다.
```

**포인트:**
- 문제 상황을 구체적으로 설명
- 청중이 공감할 수 있도록
- 의문을 던지며 흥미 유발

---

### 슬라이드 3: 실제 코드 - Before

**스크립트:**
```
처음 제가 작성했던 코드를 보시면, (코드를 가리키며)
굉장히 단순합니다.

1. 댓글을 조회하고
2. 좋아요 수를 증가시키고
3. 저장한다

언뜻 보면 문제가 없어 보이죠?

(잠시 멈춤)

하지만 여기, 이 incrementLikeCount() 메서드가 호출되는 순간,
여러 스레드가 동시에 같은 데이터를 읽고 수정하려고 합니다.

이게 바로 문제의 시작이었습니다.
```

**포인트:**
- 코드를 천천히 설명
- 문제가 발생하는 지점 명확히 표시
- 청중이 따라올 수 있도록 속도 조절

---

### 슬라이드 4: 왜 문제가 발생했을까?

**스크립트:**
```
그렇다면 왜 이런 문제가 발생한 걸까요?

(정의를 읽으며)
동시성이란, 여러 작업이 동시에 실행되는 것처럼 보이는 것을 말합니다.

Race Condition은 여러 스레드가 공유 자원에 동시에 접근할 때,
실행 순서에 따라 결과가 달라지는 상황을 말합니다.

(잠시 멈춤)

이 문제를 제대로 이해하고 해결하려면,
스레드가 무엇인지, 어떻게 동작하는지부터 알아야 했습니다.

그래서 저는 스레드의 기본 원리부터 다시 공부하기 시작했습니다.
```

**포인트:**
- 용어 정의 명확히
- 문제의 본질 파악
- 다음 섹션으로 자연스럽게 전환

---

## 2부: 승(承) - 원리의 이해

### 슬라이드 5: 프로세스 vs 스레드

**스크립트:**
```
스레드를 이해하기 위해서는 먼저 프로세스를 알아야 합니다.

(비유를 설명하며)
제가 좋아하는 비유가 있는데요, 집으로 비유하면 이해하기 쉽습니다.

프로세스는 한 가구, 즉 하나의 세대입니다.
독립된 집을 가지고 있고, 다른 집에 함부로 들어갈 수 없죠.

스레드는 그 집에 사는 세대원입니다.
같은 집에 살면서, 거실과 주방 같은 공용 공간을 함께 씁니다.

하지만 각자의 방은 따로 있죠.
이 개인 방이 바로 Stack입니다.

거실과 주방 같은 공용 공간이 Heap입니다.

(잠시 멈춤)

이 비유를 머릿속에 그리고 계시면,
앞으로 설명이 훨씬 이해하기 쉬우실 겁니다.
```

**포인트:**
- 비유를 천천히, 명확하게
- 청중이 이미지를 떠올릴 시간 주기
- 핵심 개념(독립/공유) 강조

---

### 슬라이드 6-7: 프로세스와 스레드의 특징

**스크립트:**
```
좀 더 기술적으로 들어가보겠습니다.

(슬라이드 6)
프로세스는 독립된 메모리 공간을 가집니다.
Code, Data, Heap, Stack 영역을 모두 독립적으로 소유하죠.

다른 프로세스의 메모리에는 절대 접근할 수 없습니다.
이게 프로세스의 안정성이면서, 동시에 무거운 이유이기도 합니다.

(슬라이드 7로 넘어가며)
반면 스레드는 어떨까요?

같은 프로세스 내의 스레드들은 Code, Data, Heap 영역을 공유합니다.
오직 Stack만 각자 독립적으로 가지고 있죠.

이게 스레드가 가벼운 이유입니다.
새로운 메모리 공간을 만들 필요가 없으니까요.

하지만... (잠시 멈춤)

공유한다는 것은 동시성 문제가 발생할 수 있다는 의미이기도 합니다.
```

**포인트:**
- 기술적 내용이지만 쉽게 설명
- 장단점을 명확히
- 동시성 문제로 자연스럽게 연결

---

### 슬라이드 8: 스레드의 존재 이유

**스크립트:**
```
그렇다면 이렇게 복잡한 스레드를 왜 사용하는 걸까요?

(질문을 던지듯)
여러분, 웹 브라우저를 생각해보세요.
동시에 여러 탭을 열고, 영상도 보고, 파일도 다운로드 받죠?

만약 스레드가 하나뿐이라면?
한 번에 한 가지 일밖에 못 합니다.

(강조하며)
스레드의 존재 이유는 바로 "효율"입니다.
여러 일을 동시에 처리해서 효율을 극대화하는 것이죠.

특히 요즘같이 멀티코어 CPU 시대에는
스레드를 잘 활용하는 것이 성능의 핵심입니다.
```

**포인트:**
- 실생활 예시로 쉽게 설명
- 스레드의 가치 강조
- 현대 컴퓨팅 환경과 연결

---

### 슬라이드 9-11: OS 스레드 vs 자바 스레드

**스크립트:**
```
이제 조금 더 깊이 들어가보겠습니다.

(슬라이드 9)
OS 스레드는 운영체제 레벨에서 관리되는 스레드입니다.
Windows, Linux, macOS마다 구현 방식이 다릅니다.

(슬라이드 10)
반면 자바 스레드는 JVM이 관리합니다.
중요한 점은, 자바 스레드가 OS 스레드를 감싸고 있다는 거예요.

(슬라이드 11, 다이어그램을 가리키며)
이렇게 동작합니다.

자바 코드에서 new Thread()를 호출하면,
JVM이 OS에게 "스레드 하나 만들어줘"라고 요청합니다.
OS가 네이티브 스레드를 만들면,
JVM이 자바 스레드와 1대1로 매핑시킵니다.

이런 추상화 덕분에 우리는 OS 종류에 상관없이
같은 자바 코드로 멀티스레딩을 할 수 있는 겁니다.

"Write Once, Run Anywhere"의 철학이 여기에도 적용되는 거죠.
```

**포인트:**
- 추상화 개념 설명
- 다이어그램 활용해 시각적 설명
- JVM의 역할 강조

---

### 슬라이드 12-14: 스레드의 생명주기

**스크립트:**
```
스레드는 생명주기를 가지고 있습니다.

(다이어그램을 따라가며)
NEW: Thread 객체를 만들었지만 아직 시작하지 않은 상태
RUNNABLE: start()를 호출해서 실행 준비가 된 상태
RUNNING: 실제로 CPU를 할당받아 실행 중인 상태
WAITING/BLOCKED: 뭔가를 기다리는 상태
TERMINATED: 실행이 끝난 상태

(슬라이드 14, 중요한 포인트)
여기서 정말 중요한 게 있습니다.

(강조하며)
스케줄러가 언제 어떤 스레드를 실행할지 결정합니다.
개발자는 이 순서를 제어할 수 없습니다!

그래서 우리는 어떤 순서로 실행되더라도 문제없도록
방어적인 코드를 작성해야 합니다.

이게 바로 동시성 제어가 필요한 이유입니다.
```

**포인트:**
- 상태 전환 명확히 설명
- 스케줄러의 역할 강조
- 방어적 프로그래밍의 필요성 연결

---

### 슬라이드 15-17: 공유 자원과 동시성 문제

**스크립트:**
```
이제 핵심에 다가왔습니다.

(슬라이드 15)
동시성 문제의 핵심은 바로 "공유 자원"입니다.

Stack은 각 스레드의 독립 공간입니다. 문제없죠.
하지만 Heap은 모든 스레드가 공유하는 공간입니다.

(강조하며)
여러 스레드가 동시에 같은 Heap 메모리를 수정하려고 할 때,
바로 문제가 발생합니다.

(슬라이드 16, Race Condition 다이어그램)
실제로 어떻게 발생하는지 볼까요?

Thread 1이 count를 읽습니다. 0이네요.
Thread 2도 거의 동시에 count를 읽습니다. 역시 0입니다.

Thread 1이 1을 더해서 1을 씁니다.
Thread 2도 1을 더해서 1을 씁니다.

(잠시 멈춤)

예상은 2였는데, 실제로는 1입니다.
이게 바로 Race Condition입니다.

(슬라이드 17)
동시성 문제는 크게 두 가지입니다.

원자성 문제: 읽기-수정-쓰기 같은 여러 단계가 중간에 끊기는 문제
가시성 문제: CPU 캐시와 메인 메모리가 동기화되지 않는 문제

우리가 겪었던 문제는 바로 원자성 문제였습니다.
```

**포인트:**
- 타임라인으로 시각적 설명
- 구체적인 숫자로 이해 돕기
- 두 가지 문제 유형 명확히 구분

---

### 슬라이드 18: TV 리모컨 비유

**스크립트:**
```
다시 한번 쉬운 비유로 돌아가볼게요.

(웃으며)
집에서 TV 리모컨 전쟁 벌여보신 적 있으신가요?

여러 사람이 동시에 TV 채널을 바꾸려고 하면
채널이 막 왔다갔다하고, 결국 아무도 원하는 채널을 못 보게 되죠.

(잠시 멈춤)

해결책은 간단합니다.
"TV 리모컨은 한 번에 한 사람만!"

이게 바로 락(Lock)의 개념입니다.

자, 이제 문제의 원인을 이해했으니,
어떻게 해결할 수 있는지 알아봅시다.
```

**포인트:**
- 가벼운 분위기 전환
- 청중의 경험 환기
- 다음 파트로 자연스러운 전환

---

## 3부: 전(轉) - 해결의 방법

### 슬라이드 19: 동시성 제어 전략 개요

**스크립트:**
```
자바에서 동시성을 제어하는 방법은 크게 두 가지 레벨로 나뉩니다.

(1번을 가리키며)
첫 번째, 메모리 레벨 제어입니다.
애플리케이션 코드에서 직접 동기화하는 방법이죠.
synchronized, Lock, volatile 같은 키워드들을 사용합니다.

(2번을 가리키며)
두 번째, 데이터베이스 레벨 제어입니다.
DB의 트랜잭션과 락 메커니즘을 활용하는 방법입니다.

(잠시 멈춤)

저는 우리 문제가 DB 데이터의 정합성 문제였기 때문에,
데이터베이스 레벨의 비관적 락을 선택했습니다.

하나씩 살펴보겠습니다.
```

**포인트:**
- 전체 구조 먼저 제시
- 각 레벨의 차이 명확히
- 선택한 방법과 이유 설명

---

### 슬라이드 20: 메모리 레벨 제어

**스크립트:**
```
먼저 메모리 레벨 제어 방법들을 간단히 보겠습니다.

(synchronized 코드)
synchronized는 가장 기본적인 방법입니다.
메서드나 블록에 락을 거는 거죠.

(volatile 코드)
volatile은 가시성 문제를 해결합니다.
CPU 캐시를 거치지 않고 메인 메모리에서 직접 읽고 씁니다.

(Concurrent Collections)
그리고 자바는 동시성을 위한 특별한 컬렉션들도 제공합니다.
ConcurrentHashMap, AtomicInteger 같은 것들이죠.

이런 방법들도 유용하지만,
우리 경우에는 DB 데이터를 다루기 때문에 충분하지 않았습니다.
```

**포인트:**
- 각 방법의 특징 간략히
- 너무 깊이 들어가지 않기
- DB 레벨 방법이 필요한 이유 설명

---

### 슬라이드 21-22: 데이터베이스 레벨 제어

**스크립트:**
```
(슬라이드 21)
저희가 선택한 해결책, 비관적 락입니다.

(코드를 가리키며)
보시면 @Lock 어노테이션과 PESSIMISTIC_WRITE를 사용했습니다.

이게 SQL로 번역되면 어떻게 될까요?
바로 "SELECT ... FOR UPDATE"입니다.

(강조하며)
FOR UPDATE가 핵심입니다.
이 구문은 해당 행에 배타적 락을 겁니다.

트랜잭션이 끝날 때까지 다른 트랜잭션은 기다려야 합니다.
줄을 서는 거죠.

(슬라이드 22, 표를 보며)
비관적 락 vs 낙관적 락, 언제 뭘 써야 할까요?

비관적 락은 "충돌이 자주 발생할 거야"라고 가정합니다.
그래서 미리 락을 걸어버립니다.

낙관적 락은 "충돌이 드물 거야"라고 가정합니다.
Version을 체크해서, 충돌이 발생하면 재시도합니다.

(실무 팁)
저의 경험상, 좋아요나 재고 관리 같이
충돌이 자주 발생하는 경우엔 비관적 락이 안정적입니다.

조회가 많고 수정이 적은 경우엔 낙관적 락이 효율적이고요.
```

**포인트:**
- SQL로의 변환 설명 (이해 향상)
- 실무 경험 공유
- 상황별 선택 기준 제시

---

### 슬라이드 23-26: 실제 구현 코드 분석

**스크립트:**
```
(슬라이드 23)
자, 이제 실제로 문제를 해결한 코드를 봅시다.

(코드를 따라가며)
1. findByIdWithPessimisticLock으로 댓글을 조회합니다.
   이 순간 락을 획득합니다.

2. 좋아요 여부를 체크하고 토글합니다.

3. 트랜잭션이 커밋되면서 락이 해제됩니다.

(실행 흐름 박스를 가리키며)
Thread 1이 락을 먼저 획득하면,
Thread 2와 3은 기다립니다.

Thread 1이 끝나면, Thread 2가 락을 획득하고,
Thread 2가 끝나면, Thread 3가 락을 획득합니다.

완벽하게 순서대로 처리됩니다!

(슬라이드 24, 테스트 코드)
이게 우리가 작성한 동시성 테스트입니다.

ExecutorService로 스레드 풀을 만들고,
CountDownLatch로 모든 스레드를 동기화하고,
AtomicInteger로 성공 횟수를 카운트합니다.

(슬라이드 25)
각 도구의 역할을 하나씩 설명드리면...

ExecutorService: 스레드를 효율적으로 관리합니다.
CountDownLatch: 메인 스레드가 작업 스레드들을 기다립니다.
AtomicInteger: 동시성 환경에서 안전한 카운터입니다.

(슬라이드 26)
마지막으로, @Transactional의 역할입니다.

트랜잭션이 커밋될 때 모든 변경사항이
메인 메모리, 즉 데이터베이스에 반영됩니다.

이렇게 가시성 문제도 해결됩니다.
다른 스레드가 항상 최신값을 읽을 수 있습니다.
```

**포인트:**
- 코드를 천천히, 단계별로 설명
- 시각 자료(흐름도) 적극 활용
- 각 컴포넌트의 역할 명확히
- 원자성과 가시성 모두 해결됨을 강조

---

## 4부: 결(結) - 정리와 교훈

### 슬라이드 27: 실무 적용 결과

**스크립트:**
```
자, 그래서 결과가 어땠을까요?

(체크마크를 가리키며)
완벽했습니다!

동시 요청 1000개, 성공 처리 1000개,
최종 좋아요 수 정확히 1000개!

데이터 정합성 100% 보장!

(만족스러운 표정으로)
처음 겪었을 때는 막막했는데,
원리를 이해하고 적절한 도구를 선택하니
깔끔하게 해결되었습니다.
```

**포인트:**
- 성공의 기쁨 공유
- 구체적인 수치로 결과 제시
- 긍정적인 에너지

---

### 슬라이드 28: 동시성 제어 선택 가이드

**스크립트:**
```
그렇다면 실무에서 어떤 방법을 선택해야 할까요?

(각 항목을 가리키며)
단순 카운터나 플래그는 AtomicInteger, volatile로 충분합니다.

메모리상의 객체를 보호해야 한다면 synchronized나 Lock을 쓰세요.

DB 데이터인데 충돌이 적다? 낙관적 락이 효율적입니다.

DB 데이터인데 충돌이 많다? 비관적 락으로 안정성을 확보하세요.

복잡한 비즈니스 로직이라면? 트랜잭션과 락을 조합하세요.

(잠시 멈춤)

정답은 없습니다. 상황에 맞는 선택이 중요합니다.
```

**포인트:**
- 실용적인 가이드 제공
- 각 상황별 명확한 기준
- 맥락의 중요성 강조

---

### 슬라이드 29: 주의사항 및 베스트 프랙티스

**스크립트:**
```
동시성 제어를 할 때 주의할 점들입니다.

(주의사항)
첫째, 데드락 조심하세요. 여러 락을 획득할 때 순서를 일관되게!
둘째, 락의 범위는 최소화하세요. 성능을 위해서입니다.
셋째, 스케줄러를 믿지 마세요. 실행 순서는 예측 불가능합니다.
넷째, 방어적으로 프로그래밍하세요. 어떤 순서로 실행되어도 안전하게!

(베스트 프랙티스)
그리고 이것만은 꼭 기억하세요.

공유 자원을 명확히 파악하고,
최소한의 범위만 동기화하고,
적절한 수준의 락을 선택하고,
반드시 테스트 코드를 작성하세요!

(강조하며)
특히 테스트 코드! 동시성 버그는 재현하기 어렵습니다.
테스트로 미리 잡아내는 게 정말 중요합니다.
```

**포인트:**
- 실무 경험에서 우러나온 조언
- 강조할 부분은 목소리 크게
- 테스트의 중요성 재차 강조

---

### 슬라이드 30-31: 핵심 교훈

**스크립트:**
```
(슬라이드 30)
이제 마무리하면서, 핵심 교훈을 정리하겠습니다.

(각 포인트를 천천히)

첫째, 진짜 공유 자원이 무엇인지 파악하세요.
"여러 스레드가 동시에 수정하려는 대상이 뭐지?"

둘째, 원자성과 가시성 문제를 이해하세요.
연산이 끊기지 않도록, 변경사항이 보이도록.

셋째, 적절한 제어 방법을 선택하세요.
상황에 맞는 도구를 쓰는 것이 중요합니다.

넷째, 방어적 코드를 작성하세요.
실행 순서에 의존하지 말고, 항상 동시성을 고려하세요.

(슬라이드 31)
마지막 질문, 스레드와 동시성의 깊은 이해는 왜 필요할까요?

(각 항목을 가리키며)
안정적인 서비스 운영을 위해,
성능 최적화를 위해,
확장 가능한 아키텍처를 위해,
그리고 문제 해결 능력 향상을 위해!

(강조하며)
동시성은 어렵습니다. 하지만 꼭 필요합니다.
특히 대용량 트래픽을 다루는 서비스에서는 필수입니다.
```

**포인트:**
- 핵심 메시지 반복
- 명확하고 간결하게
- 중요성 강조

---

### 슬라이드 32-33: 추가 학습 자료 & Q&A

**스크립트:**
```
(슬라이드 32)
더 깊이 공부하고 싶으신 분들을 위해 자료를 준비했습니다.

"Java Concurrency in Practice"는 바이블 같은 책입니다.
OS 공룡책으로 기본기를 다지시고,
Virtual Thread 같은 최신 기술도 알아보세요.

무엇보다 직접 구현해보세요!
이론만 아는 것과 직접 해보는 것은 천지차이입니다.

(슬라이드 33)
이제 질문 받겠습니다!

(예상 질문들을 보며)
분산 환경에서는? Redis 락 같은 분산 락을 사용합니다.
Virtual Thread는? Java 21의 경량 스레드입니다.
성능 테스트는? JMeter나 Gatling 같은 도구를 씁니다.

(청중을 보며)
이 외에도 궁금한 점 있으시면 편하게 질문해주세요!
```

**포인트:**
- 학습 자료 소개
- 질문 유도
- 편안한 분위기 조성

---

### 슬라이드 34: 마무리

**스크립트:**
```
(슬라이드를 보며)
오늘 발표 들어주셔서 감사합니다.

(핵심 메시지를 읽으며)
"동시성 제어는 어려운 주제이지만,
기본 원리를 이해하면 실무에서 충분히 적용할 수 있습니다."

(개인적인 경험을 나누며)
저도 처음엔 막막했습니다.
하지만 문제를 만나고, 원리를 공부하고, 해결하고,
그 과정에서 배우면서 성장할 수 있었습니다.

(청중을 향해)
여러분도 실무에서 동시성 문제를 만나실 겁니다.
그때 오늘 배운 내용이 도움이 되었으면 좋겠습니다.

(마지막 인사)
다시 한번 감사드립니다.
추가 질문이나 의견 있으시면 언제든 연락주세요!

(박수를 기다리며 미소)
```

**포인트:**
- 진심 어린 마무리
- 개인적 경험 공유로 친근감
- 긍정적이고 희망찬 메시지
- 자신감 있는 마무리

---

## 🎤 발표 팁 종합

### 목소리 & 발음
- 천천히, 명확하게
- 중요한 부분은 강조
- 톤에 변화 주기
- 잠시 멈춤 활용

### 제스처 & 아이컨택
- 슬라이드 가리키며 설명
- 청중과 눈 맞추기
- 자연스러운 손동작
- 자신감 있는 자세

### 시간 관리
- 1부: 5-7분
- 2부: 15-18분
- 3부: 10-12분
- 4부: 5-8분
- 총 35-45분 (질의응답 포함)

### 위기 대응
- 질문 못 들었을 때: "다시 한번 말씀해주시겠어요?"
- 대답 모를 때: "좋은 질문이네요. 저도 더 알아봐야할 것 같습니다."
- 시간 부족할 때: 덜 중요한 슬라이드 빠르게 넘기기
- 실수했을 때: 당황하지 말고 웃으며 정정

### 마인드셋
- 청중은 적이 아닌 동료
- 완벽하지 않아도 괜찮다
- 실수는 자연스러운 것
- 즐기자!

---

좋은 발표 되길 바랍니다! 화이팅! 🎉
